# %%
import streamlit as st
from st_aggrid import AgGrid
from snowflake.snowpark.session import Session
from snowflake.snowpark.functions import *
import json
import pandas as pd
import numpy as np
from math import sqrt
from sklearn.cluster import KMeans
import seaborn as sns

# Set page config
st.set_page_config(layout="wide")

# %%
# Create a session to Snowflake with credentials
with open("creds.json") as f:
    connection_parameters = json.load(f)
session = Session.builder.configs(connection_parameters).create()

# %%
# Header
html_temp_title = """
    <div style="background-color:#154360;padding:2px">
    <h2 style="color:white;text-align:center;">Retail Revenue Generated by Customers</h2>
    </div>
"""
st.markdown(html_temp_title, unsafe_allow_html=True)
st.markdown("")

# Read data CSV for finding KNNs and Clusters
df = pd.read_csv('data.csv')
df_np_full = df.to_numpy()
df_np = df_np_full[:,2:]

# Plot Clusters of Customers in Data
import plotly.express as px
    
def cluster_plot(data_frame):
    fig = px.scatter_3d(data_frame, x = 'Session Length on App', y='Session Length on Website', z='Yearly Expenditure',
              color='Cluster', opacity = 0.8, size='Duration of Subscription in Years', width=750, height=500, template="plotly_dark")
    fig.update_layout(height=700)
    st.plotly_chart(fig, use_container_width=True, height=700)
    
def kmeans_on_df(df_np):
    kmeans = KMeans(n_clusters = 3, init="k-means++", max_iter = 300, n_init = 10, random_state = 123)
    identified_clusters = kmeans.fit_predict(df_np)
    data_with_clusters = df.copy()
    data_with_clusters['Cluster'] = identified_clusters.tolist()
    return data_with_clusters

col1, col2, col3= st.columns([5, 1, 10])

# Read table for final data
customer_df = session.table('PREDICTED_CUSTOMER_SPEND')

# Read Data
minasl, maxasl, mintoa, maxtoa, mintow, maxtow, minlom, maxlom = customer_df.select(
    floor(min(col("Avg. Session Length"))),
    ceil(max(col("Avg. Session Length"))),
    floor(min(col("Session Length on App"))),
    ceil(max(col("Session Length on App"))),
    floor(min(col("Session Length on Website"))),
    ceil(max(col("Session Length on Website"))),
    floor(min(col("Duration of Subscription in Years"))),
    ceil(max(col("Duration of Subscription in Years")))
).toPandas().iloc[0, ]

minasl = int(minasl)
maxasl = int(maxasl)
mintoa = int(mintoa)
maxtoa = int(maxtoa)
mintow = int(mintow)
maxtow = int(maxtow)
minlom = int(minlom)
maxlom = int(maxlom)

# Column 1
with col1:
    html_temp_title = """
            <div style="background-color:SteelBlue;padding:4px">
            <h4 style="color:white;text-align:center;">Set Parameters</h4>
            </div>
        """
    st.markdown(html_temp_title, unsafe_allow_html=True)
    st.markdown('##')
    asl = st.slider('Avg. Session Length', minasl, maxasl, (minasl, minasl + 5), step = 1)
    toa = st.slider("Session Length on App", mintoa, maxtoa, (mintoa, mintoa + 5), step = 1)
    tow = st.slider("Session Length on Website", mintow, maxtow, (mintow, mintow + 5), step = 1)
    lom = st.slider("Duration of Subscription in Years", minlom, maxlom, (minlom, minlom + 4), step = 1)
    
    # Calculate minimum and maximum spending
    minspend, maxspend = customer_df.filter(
        (col("Avg. Session Length") <= asl[1]) & (col("Avg. Session Length") > asl[0])
        & (col("Session Length on App") <= toa[1]) & (col("Session Length on App") > toa[0])
        & (col("Session Length on Website") <= tow[1]) & (col("Session Length on Website") > tow[0])
        & (col("Duration of Subscription in Years") <= lom[1]) & (col("Duration of Subscription in Years") > lom[0])
    ).select(trunc(min(col('PREDICTED_SPEND'))), trunc(max(col('PREDICTED_SPEND')))).toPandas().iloc[0, ]
    
    avg_expenditure = (minspend + maxspend)/2
    st.header(f'Expected Revenue:')
    st.metric(label="", value=f"${avg_expenditure}")
    
with col3:
    html_temp_title = """
            <div style="background-color:SteelBlue;padding:4px">
            <h4 style="color:white;text-align:center;">Identified Clusters Based on App/Website Usage</h4>
            </div>
        """
    st.markdown(html_temp_title, unsafe_allow_html=True)
    st.markdown("")
    cluster_plot(kmeans_on_df(df_np))

    
st.markdown("---")
     
# Calculate the Euclidean distance between two vectors
def euclidean_distance(row1, row2):
    distance = 0.0
    for i in range(len(row1)-1):
        distance += (row1[i] - row2[i])**2
    return sqrt(distance)

# Locate the most similar neighbors
def get_neighbors(train_full, train, test_row, num_neighbors):
    distances = list()
    for full_row, train_row in zip(train_full, train):
        dist = euclidean_distance(test_row, train_row[:-1])
        distances.append((full_row, dist))
        distances.sort(key=lambda tup: tup[1])
    neighbors = list()
    for i in range(num_neighbors):
        neighbors.append(distances[i][0])
    return neighbors

html_temp_title = """
        <div style="background-color:SteelBlue;padding:4px">
        <h4 style="color:white;text-align:center;">Top 5 Customer Data with Similar Behaviour</h4>
        </div>
    """
st.markdown(html_temp_title, unsafe_allow_html=True)
st.markdown('##')
closest = get_neighbors(df_np_full,df_np, np.array([np.mean(asl),np.mean(toa),np.mean(tow),np.mean(lom)]), 5)
df_neighbours = pd.DataFrame(closest, columns = df.columns)
df_neighbours = df_neighbours.loc[:, df_neighbours.columns != 'Customer Address']
AgGrid(df_neighbours, theme = 'alpine',height = 200, width = 150)
